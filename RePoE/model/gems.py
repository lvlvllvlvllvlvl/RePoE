# generated by datamodel-codegen:
#   filename:  gems.schema.json

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, ConfigDict, RootModel


class PerLevelCosts(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Mana: Optional[int] = None
    Life: Optional[int] = None
    ManaPerMinute: Optional[int] = None
    ES: Optional[int] = None


class PerLevelReservations(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mana_flat: Optional[int] = None
    mana_percent: Optional[float] = None


class StatRequirements(BaseModel):
    int: Optional[Any] = None
    str: Optional[Any] = None
    dex: Optional[Any] = None


class StaticCosts(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Mana: Optional[int] = None
    Life: Optional[int] = None
    ManaPercent: Optional[int] = None


class QualityStat(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    stat: str
    stats: Dict[str, int]


class StaticReservations(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mana_percent: Optional[float] = None
    life_percent: Optional[float] = None
    mana_flat: Optional[int] = None


class Vaal(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    souls: int
    stored_uses: int


class MinionTypeElement(RootModel[str]):
    root: str


class WeaponRestriction(RootModel[str]):
    root: str


class ExperienceType(RootModel[str]):
    root: str


class ReleaseState(Enum):
    released = 'released'
    unreleased = 'unreleased'
    legacy = 'legacy'


class Color(Enum):
    r = 'r'
    g = 'g'
    w = 'w'
    b = 'b'


class Discriminator(Enum):
    alt_x = 'alt_x'
    alt_y = 'alt_y'


class StatType(Enum):
    float = 'float'
    constant = 'constant'
    additional = 'additional'
    implicit = 'implicit'
    flag = 'flag'


class Class(RootModel[str]):
    root: str


class StatTranslationFile(RootModel[str]):
    root: str


class CooldownBypassType(Enum):
    expend_frenzy_charge = 'expend_frenzy_charge'
    expend_power_charge = 'expend_power_charge'
    expend_endurance_charge = 'expend_endurance_charge'


class Tag(RootModel[str]):
    root: str


class ActiveSkill(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: str
    display_name: str
    id: str
    is_manually_casted: bool
    is_skill_totem: bool
    stat_conversions: Dict[str, str]
    types: Optional[List[MinionTypeElement]] = None
    weapon_restrictions: List[WeaponRestriction]
    skill_totem_life_multiplier: Optional[float] = None
    minion_types: Optional[List[MinionTypeElement]] = None


class BaseItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    display_name: str
    experience_type: ExperienceType
    id: str
    max_level: int
    release_state: ReleaseState


class Stat(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    value: Optional[int] = None
    id: Optional[str] = None
    type: Optional[StatType] = None


class QuestReward(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    act: int
    classes: List[Class]
    quest: str


class Static(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    crit_chance: Optional[int] = None
    damage_effectiveness: Optional[int] = None
    quality_stats: List[QualityStat]
    stat_requirements: Optional[StatRequirements] = None
    stat_text: Optional[Dict[str, str]] = None
    stats: Optional[List[Optional[Stat]]] = None
    cooldown: Optional[int] = None
    stored_uses: Optional[int] = None
    required_level: Optional[int] = None
    attack_speed_multiplier: Optional[int] = None
    costs: Optional[StaticCosts] = None
    cost_multiplier: Optional[int] = None
    reservations: Optional[StaticReservations] = None
    experience: Optional[int] = None
    damage_multiplier: Optional[int] = None
    vaal: Optional[Vaal] = None
    cooldown_bypass_type: Optional[CooldownBypassType] = None


class SupportGem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allowed_types: Optional[List[MinionTypeElement]] = None
    excluded_types: Optional[List[MinionTypeElement]] = None
    letter: str
    supports_gems_only: bool
    added_types: Optional[List[MinionTypeElement]] = None
    added_minion_types: Optional[List[MinionTypeElement]] = None


class PerLevel(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    costs: Optional[PerLevelCosts] = None
    experience: Optional[int] = None
    required_level: Optional[int] = None
    stat_requirements: Optional[StatRequirements] = None
    stat_text: Optional[Dict[str, str]] = None
    stats: Optional[List[Optional[Stat]]] = None
    reservations: Optional[PerLevelReservations] = None
    damage_effectiveness: Optional[int] = None
    damage_multiplier: Optional[int] = None
    cooldown: Optional[int] = None
    cost_multiplier: Optional[int] = None
    stored_uses: Optional[int] = None


class GemsSchemaValue(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    active_skill: Optional[ActiveSkill] = None
    base_item: Optional[BaseItem] = None
    cast_time: Optional[int] = None
    color: Color
    display_name: Optional[str] = None
    is_support: bool
    per_level: Dict[str, PerLevel]
    quest_reward: Optional[QuestReward] = None
    stat_translation_file: StatTranslationFile
    static: Static
    tags: Optional[List[Tag]] = None
    discriminator: Optional[Discriminator] = None
    secondary_granted_effect: Optional[str] = None
    support_gem: Optional[SupportGem] = None


class Model(RootModel[Optional[Dict[str, GemsSchemaValue]]]):
    root: Optional[Dict[str, GemsSchemaValue]] = None
